# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyuser_event_log', [dirname(__file__)])
        except ImportError:
            import _pyuser_event_log
            return _pyuser_event_log
        if fp is not None:
            try:
                _mod = imp.load_module('_pyuser_event_log', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyuser_event_log = swig_import_helper()
    del swig_import_helper
else:
    import _pyuser_event_log
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


import nox.lib.netinet
class user_event_log_proxy(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, user_event_log_proxy, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, user_event_log_proxy, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pyuser_event_log.new_user_event_log_proxy(*args)
        try: self.this.append(this)
        except: self.this = this
    def configure(self, *args): return _pyuser_event_log.user_event_log_proxy_configure(self, *args)
    def install(self, *args): return _pyuser_event_log.user_event_log_proxy_install(self, *args)
    def log_simple(self, *args): return _pyuser_event_log.user_event_log_proxy_log_simple(self, *args)
    def log(self, *args): return _pyuser_event_log.user_event_log_proxy_log(self, *args)
    def get_log_entry(self, *args): return _pyuser_event_log.user_event_log_proxy_get_log_entry(self, *args)
    def get_max_logid(self): return _pyuser_event_log.user_event_log_proxy_get_max_logid(self)
    def get_min_logid(self): return _pyuser_event_log.user_event_log_proxy_get_min_logid(self)
    def set_max_num_entries(self, *args): return _pyuser_event_log.user_event_log_proxy_set_max_num_entries(self, *args)
    def get_logids_for_name(self, *args): return _pyuser_event_log.user_event_log_proxy_get_logids_for_name(self, *args)
    def clear(self, *args): return _pyuser_event_log.user_event_log_proxy_clear(self, *args)
    def remove(self, *args): return _pyuser_event_log.user_event_log_proxy_remove(self, *args)
    __swig_destroy__ = _pyuser_event_log.delete_user_event_log_proxy
    __del__ = lambda self : None;
user_event_log_proxy_swigregister = _pyuser_event_log.user_event_log_proxy_swigregister
user_event_log_proxy_swigregister(user_event_log_proxy)

class Name(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Name, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Name, name)
    __repr__ = _swig_repr
    NONE = _pyuser_event_log.Name_NONE
    LOCATION = _pyuser_event_log.Name_LOCATION
    HOST = _pyuser_event_log.Name_HOST
    USER = _pyuser_event_log.Name_USER
    SWITCH = _pyuser_event_log.Name_SWITCH
    PORT = _pyuser_event_log.Name_PORT
    LOC_TUPLE = _pyuser_event_log.Name_LOC_TUPLE
    LOCATION_GROUP = _pyuser_event_log.Name_LOCATION_GROUP
    HOST_GROUP = _pyuser_event_log.Name_HOST_GROUP
    USER_GROUP = _pyuser_event_log.Name_USER_GROUP
    SWITCH_GROUP = _pyuser_event_log.Name_SWITCH_GROUP
    def __init__(self, *args): 
        this = _pyuser_event_log.new_Name(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["name"] = _pyuser_event_log.Name_name_set
    __swig_getmethods__["name"] = _pyuser_event_log.Name_name_get
    if _newclass:name = _swig_property(_pyuser_event_log.Name_name_get, _pyuser_event_log.Name_name_set)
    __swig_setmethods__["name_type"] = _pyuser_event_log.Name_name_type_set
    __swig_getmethods__["name_type"] = _pyuser_event_log.Name_name_type_get
    if _newclass:name_type = _swig_property(_pyuser_event_log.Name_name_type_get, _pyuser_event_log.Name_name_type_set)
    __swig_setmethods__["id"] = _pyuser_event_log.Name_id_set
    __swig_getmethods__["id"] = _pyuser_event_log.Name_id_get
    if _newclass:id = _swig_property(_pyuser_event_log.Name_id_get, _pyuser_event_log.Name_id_set)
    def __eq__(self, *args): return _pyuser_event_log.Name___eq__(self, *args)
    def __lt__(self, *args): return _pyuser_event_log.Name___lt__(self, *args)
    __swig_destroy__ = _pyuser_event_log.delete_Name
    __del__ = lambda self : None;
Name_swigregister = _pyuser_event_log.Name_swigregister
Name_swigregister(Name)

class Loc(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Loc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Loc, name)
    __repr__ = _swig_repr
    NO_PORT = _pyuser_event_log.Loc_NO_PORT
    def __init__(self, *args): 
        this = _pyuser_event_log.new_Loc(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["dpid"] = _pyuser_event_log.Loc_dpid_set
    __swig_getmethods__["dpid"] = _pyuser_event_log.Loc_dpid_get
    if _newclass:dpid = _swig_property(_pyuser_event_log.Loc_dpid_get, _pyuser_event_log.Loc_dpid_set)
    __swig_setmethods__["port"] = _pyuser_event_log.Loc_port_set
    __swig_getmethods__["port"] = _pyuser_event_log.Loc_port_get
    if _newclass:port = _swig_property(_pyuser_event_log.Loc_port_get, _pyuser_event_log.Loc_port_set)
    def __eq__(self, *args): return _pyuser_event_log.Loc___eq__(self, *args)
    def __lt__(self, *args): return _pyuser_event_log.Loc___lt__(self, *args)
    __swig_destroy__ = _pyuser_event_log.delete_Loc
    __del__ = lambda self : None;
Loc_swigregister = _pyuser_event_log.Loc_swigregister
Loc_swigregister(Loc)

class LogEntry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogEntry, name)
    __repr__ = _swig_repr
    INVALID = _pyuser_event_log.LogEntry_INVALID
    CRITICAL = _pyuser_event_log.LogEntry_CRITICAL
    ALERT = _pyuser_event_log.LogEntry_ALERT
    INFO = _pyuser_event_log.LogEntry_INFO
    SRC = _pyuser_event_log.LogEntry_SRC
    DST = _pyuser_event_log.LogEntry_DST
    def __init__(self, *args): 
        this = _pyuser_event_log.new_LogEntry(*args)
        try: self.this.append(this)
        except: self.this = this
    def setName(self, *args): return _pyuser_event_log.LogEntry_setName(self, *args)
    def addLocationKey(self, *args): return _pyuser_event_log.LogEntry_addLocationKey(self, *args)
    def addMacKey(self, *args): return _pyuser_event_log.LogEntry_addMacKey(self, *args)
    def addIPKey(self, *args): return _pyuser_event_log.LogEntry_addIPKey(self, *args)
    __swig_destroy__ = _pyuser_event_log.delete_LogEntry
    __del__ = lambda self : None;
LogEntry_swigregister = _pyuser_event_log.LogEntry_swigregister
LogEntry_swigregister(LogEntry)

from nox.lib.core import Component
from nox.netapps.bindings_storage.pybindings_storage import Name
from nox.netapps.data.datatypes_impl import Datatypes
from nox.coreapps.pyrt.pycomponent import CONTINUE


# TODO: remove these, and use swigged values instead
# from LogEntry class
class LogLevel: 
  INVALID = 0    
  CRITICAL = 1
  ALERT = 2 
  INFO = 3 

class pyuser_event_log(Component):
    """
    Python interface for the User_Event_Log 
    """  
    def __init__(self, ctxt):
        Component.__init__(self,ctxt)
        self.proxy = user_event_log_proxy(ctxt)
        self.principal_format_map = None

    def configure(self, configuration):
        self.proxy.configure(configuration)

    def install(self): 
        self.datatypes = self.resolve(Datatypes) 
        self.register_for_bootstrap_complete(self.bootstrap_complete_cb)

    def get_fmt_str(self,type,dir):
      for k,v in self.principal_format_map.items(): 
        if v[0] == type and v[1] == dir: 
          return k
      raise Exception("Invalid type and direction for format string")

    def bootstrap_complete_cb(self,ign): 
        self.principal_format_map = {  
          "su" : (self.datatypes.USER,LogEntry.SRC),  
          "du" : (self.datatypes.USER,LogEntry.DST),  
          "sh" : (self.datatypes.HOST,LogEntry.SRC),  
          "dh" : (self.datatypes.HOST,LogEntry.DST),  
          "sn" : (self.datatypes.HOST_NETID,LogEntry.SRC),  
          "dn" : (self.datatypes.HOST_NETID,LogEntry.DST),  
          "sl" : (self.datatypes.LOCATION,LogEntry.SRC), 
          "dl" : (self.datatypes.LOCATION,LogEntry.DST),  
          "ss" : (self.datatypes.SWITCH,LogEntry.SRC),  
          "ds" : (self.datatypes.SWITCH,LogEntry.DST),  
          "sg" : (self.datatypes.GROUP,LogEntry.SRC),   
          "dg" : (self.datatypes.GROUP,LogEntry.DST),  
        }
        return CONTINUE

    def getInterface(self):
        return str(pyuser_event_log)

    def log_simple(self, app_name, level,msg):  
        self.proxy.log_simple(app_name,int(level),msg)
    
    def log_entry(self, entry):  
        self.proxy.log(entry)
    
    # convenience function for logging in one line
    # when using keys.  
    # With respect to add*Key(), this function expects one or
    # two dict arguments indicating a source key and a
    # destination key.  Variable names are:
    # src_location, dst_location, src_mac, dst_mac, src_ip, dst_ip:
    # *_location must be a tuple containing a datapathid and a port
    # *_mac must be an etheraddr
    # *_ip must be an int 
    # if you specify more than one src_* paramter, or more than
    # one dst_* parameter, the result of the function is undefined.
    # With respect to setName() functionality, this can take any of
    # the following parameters (su,du,sh,dh,sl,dl).  Each should be
    # a list of strings.  For example, to associated two source users
    # with this log message, have su = ("bob","sarah")
    # This method also special-cases the scenario when there is only
    # one name, allowing you to pass in just the string instead of
    # a tuple with one item
    # Note: Group names can only be set explicitly.  No bindings 
    # storage query returns a group name

    def log(self, app_name, level, msg, **dict):  
       
        e = LogEntry(app_name,level,msg)
        if "src_location" in dict and len(dict["src_location"]) == 2: 
          t = dict["src_location"] 
          e.addLocationKey(t[0],t[1],LogEntry.SRC)
        if "dst_location" in dict and len(dict["dst_location"]) == 2: 
          t = dict["dst_location"] 
          e.addLocationKey(t[0],t[1],LogEntry.DST)
        if "src_mac" in dict : 
          e.addMacKey(dict["src_mac"],LogEntry.SRC)
        if "dst_mac" in dict : 
          e.addMacKey(dict["dst_mac"],LogEntry.DST)
        if "src_ip" in dict : 
          e.addIPKey(dict["src_ip"],LogEntry.SRC)
        if "dst_ip" in dict : 
          e.addIPKey(dict["dst_ip"],LogEntry.DST)
      
        # for each key-value pair in the keyword args dict,
        # test if it is a format string and, and if so
        # add the corresponding names to the log entry
        for fmt,values in dict.iteritems(): 
          if fmt in self.principal_format_map :
            principal_type,dir = self.principal_format_map[fmt]
            if type(values) == type(0) or type(values) == type(0L): 
              values = (values,) 
            for uid in values: 
              e.setName(uid,principal_type,dir)
  
        #if "set_src_loc" in dict:
        #  t = dict["set_src_loc"] # expects (dpid,port) tuple
        #  e.setNameByLocation(t[0],t[1],LogEntry.SRC)
        
        #if "set_dst_loc" in dict:
        #  t = dict["set_dst_loc"] # expects (dpid,port) tuple
        #  e.setNameByLocation(t[0],t[1],LogEntry.DST) 

        self.proxy.log(e)

    def get_log_entry(self,logid, cb):
        self.proxy.get_log_entry(logid,cb) 

    def get_max_logid(self):
        return self.proxy.get_max_logid()
    
    def get_min_logid(self):
        return self.proxy.get_min_logid()
  
    def set_max_num_entries(self,num): 
        self.proxy.set_max_num_entries(num)

    def get_logids_for_name(self,name,name_type,cb): 
        self.proxy.get_logids_for_name(name,name_type,cb) 

    def clear(self,cb):
        self.proxy.clear(cb)

    def remove(self,max_logid,cb):
        self.proxy.remove(max_logid,cb)

def getFactory():
      class Factory():
          def instance(self, context):
              return pyuser_event_log(context)

      return Factory()



