#!/usr/bin/env python
# -*- python -*-

#
# svcbrkd
#
# Copyright (C) 2012 Nextworks s.r.l.
#
# @LICENSE_BEGIN@
# @LICENSE_END@
#
# Written by: Alessandro Canessa    <a DOT canessa AT nextworks DOT it>
#

me = "topologymgrd"

try:
    import sys
    import os
    import getopt
    import inspect
    import shlex
except Exception, e:
    m = ""
    if e is not None :
        m = " (" + str(e) + ")"
    print("Cannot import required system modules" + m + ", bailing out ...")
    exit(1)

sys.path.insert(0, "@pythondir@")
path = os.getcwd()
sys.path.append(path)

try:
    import network

except Exception, e:
    m = ""
    if e is not None :
        m = " (" + str(e) + ")"
    print("Cannot import required package modules" + m + ", bailing out ...")
    sys.exit(1)

class BaseError(Exception):
    def __init__(self, m = None):
        self.message = m

    def __str__(self):
        return self.message

class CommandError(BaseError):
    def __init__(self, message):
        super(CommandError, self).__init__(message)

class WrongParametersCount(CommandError):
    def __init__(self, message):
        super(WrongParametersCount, self).__init__(message)

class WrongParameterType(CommandError):
    def __init__(self, message):
        super(WrongParameterType, self).__init__(message)

class UnknownMessage(BaseError):
    def __init__(self, message):
        super(UnknownMessage, self).__init__(message)

def check_args_count(args, min_count, max_count):
    assert(args is not None)
    assert(min_count is not None)
    assert(max_count is None or min_count <= max_count)

    if len(args) < min_count:
        tmp = "Too few arguments for command, minimum " \
            "%d arguments required" % min_count
        raise WrongParametersCount(tmp)

    if max_count is not None:
        if len(args) > max_count:
            tmp = "Too many arguments for command, " \
                " maximum %d allowed" % max_count
            raise WrongParametersCount(tmp)

def handle_command(client, message):
    assert(client  is not None)
    assert(message is not None)

    try:
        client.connect()
    except Exception, e:
        raise Exception("Cannot connect to server ('%s')" % str(e))
    if client.connected():
        try:
            network.message_send(client.socket(), message)
        except Exception, e:
            raise Exception("Cannot send message to ('%s')" % str(e))

        try:
            return "ECCO"
            #return network.message_recv(client.socket())
        except Exception, e:
            raise Exception("Cannot receive message response ('%s')" % str(e))

def command_exit(parms):
    """Exit from CLI"""
    check_args_count(parms, 0, 0)

    print("Explicit exit ...")
    sys.exit(0)

def command_show(parms):
    """Show DB"""
    check_args_count(parms, 0, 0)

    # XXX FIXME: Fill with proper values
    server_host = "10.0.2.226"
    server_port = 6001
    timeout     = 5
    name        = "test"
    client      = network.Client(name, server_host, server_port, timeout)

    response = handle_command(client, "PROVA")
    print(response)

def command_help(parms):
    """Print this help"""
    check_args_count(parms, 0, 0)

    commands = command_handlers.keys()
    commands.sort()

    maxl = 0
    for k in commands:
        maxl = max(maxl, len(k))

    for k in commands:
        # XXX FIXME: Add (autogenerated) sub-command help
        h = inspect.getdoc(command_handlers[k])
        if h is None:
            h = ""
        print(("  %-" + str(maxl) + "s    %s") % (k, h))

command_handlers = {
    'exit'                 : command_exit,
    'help'                 : command_help,
    '?'                    : command_help,

    'show'                 : command_show,
}

def dump_help():
    print(me + " [OPTIONS]")
    print("")
    print("Options:")
    print("    -d, --debug                 set log level to debug")
    print("    -h, --help                  print this help, then exit")
    print("        --version               print version, then exit")
    print("")

def version():
    print("VERSION:")

def dump_version():
    print(me + " (" + version() + ")")

variables = { }

def main(argv):

    configuration = [ ]
    try:
        optlist, args = getopt.getopt(sys.argv[1:],
                                      'c:hVd',
                                      [ "config",
                                        "help",
                                        "version",
                                        "debug"])

        for opt, arg in optlist:
            if opt in ("-h", "--help"):
                dump_help()
                return 0
            elif opt in ("-V", "--version"):
                dump_version()
                return 0
            elif opt in ("-d", "--debug"):
                print("Debug mode...")
            elif opt in ("-c", "--config"):
                try:
                    f = file(arg, 'U')
                    configuration = f.readlines()
                    f.close()
                except:
                    print("Cannot open file '%s'" % arg)
                    sys.exit(1)

    except getopt.GetoptError, err:
        dump_help()
        return 1
    except Exception, e:
        message = "Got unhandled exception "
        if (e is not None) :
            message = message + "(" + str(e) + ")"
        print(message)
        print("Report bugs to <" + "@PACKAGE_BUGREPORT@" + ">")
        return 1

    print(version())
    try:
        print("Running....")
    except KeyboardInterrupt, e:
        raise e

    while True:
        try:
            print("Accepting new line")
            if len(configuration) == 0:
                prompt = me + "> "
                line = raw_input(prompt)
            else:
                line = configuration.pop(0)
        except EOFError, e:
            print("")
            continue
        line = line.strip()
        if len(line) == 0:
            continue

        tokens    = shlex.split(line)
        command   = tokens[0]
        arguments = tokens[1:]

        if command[0] == '#':
            continue

        print("Command   = '%s'" % command)
        print("Arguments = '%s'" % str(arguments))

        handler = None

        if not command in command_handlers.keys():
            print("Unknown command '%s'" % command)
            continue

        handler = command_handlers[command]
        assert(handler is not None)
        print("Handler for command '%s' is '%s'" % (command, handler))

        try:
            print("Gonna call handler '%s'" % str(handler))
            handler(arguments)
            print("Handler '%s' has been called" % str(handler))
        except Exception, e:
            print("%s" % str(e))
            continue
    return 0

#
# Main
#
if __name__ == "__main__":
    retval = 1
    try:
        retval = main(sys.argv[1:])
    except KeyboardInterrupt:
        print("Bye, bye ...")
        retval = 0
    except Exception, e:
        print(me + ": Unhandled exception (%s)" % str(e))
        print(me + ":")
        print(me + ":   <<< Trace dump >>>")
        for i in inspect.trace():
            print(me + ": " + str(i))
        print(me + ":   <<< Trace dump >>>")
        print(me + ":")
        print(me + ":   <<< Stack dump >>>")
        for i in inspect.stack():
            print(me + ": " + str(i))
        print(me + ":   <<< Stack dump >>>")
        print(me + ":")
        print(me + ": ""Please report this problem ")
    sys.exit(retval)
sys.exit(0)
